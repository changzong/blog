---
layout: post
title:  "对Scala web开发框架Lift中Comet长连接的重新设计"
date:   2016-04-21 14:47:00
categories: jekyll update
---

### 背景

最近做了不少的后端开发，主要运用Scala进行日志数据的实时处理，并使用Scala为基础的Web开发框架Lift来将数据实时展现在前端页面。具体流程如下：

* 用户的行为日志通过移动终端埋点发送到我们的日志服务器上。
* 日志服务器通过Flume同步到Kafka上。（同时复制一份存储于HDFS上以备离线查询）
* Kafka针对不同的包分配Topic，按照消息发送出来。
* 我这边通过Scala的API启动Kafka接收服务器来接收日志消息。
* 再启动Spark Streaming流来将Kafka里的日志以一定时间间隔接收到后端。
* 在Scala程序后端使用Spark对日志进行计算处理。
* 最后通过Lift框架的Comet机制以长连接的形式实时展现在前端页面上。

### 问题

Lift的Comet是这个框架非常有用的一个特点，它能够很轻松地在页面上将数据实时更新，无需刷新页面。官网给出的聊天室的例子能很好地证实这一点。但是，Comet仅支持广播形式，即所有连接上服务器的前端页面将得到完全一样的服务器发送来的数据，无法个性化定制数据显示方案，更不能根据用户在页面上的操作来筛选数据。而在我的页面上，我需要达到的效果是，用户通过下拉菜单中的Topic选择要查看的日志数据流，并能够主动停止日志的滚动显示，如果还按照默认的Comet模式，那完全不可能达到这种要求的效果，但是我又需要Comet这种长连接的方式，于是我决定自己设计数据流动模型，配合Comet机制来实现此功能。

### 设计方案

在服务启动的时候为每一个Topic开启一个流来接收Kafka的数据。当用户在前端选择某个topic并点击开始显示后，后端为该显示请求开启一个线程，将流里的每一条日志数据就被在末位加上了那个用户的session id，

同时，在页面加载的时候在页面上的url内加上一个当前用户session id的参数。 

之后，在进行Comet长连接输出的时候根据每个访问用户页面上url内的session id，与每条日志数据里标注的session id做对比，如果一致则输出到拥有那个session id的页面上。

总体思路就是：多个流的数据注入到一个处理服务中，再通过每个用户的线程过滤掉不属于他的日志数据，呈现出相符合的数据。

### 实现效果

这样优化之后，就能够实现只要session id不同的页面上日志显示的操作和效果是互不影响的。从而实现了利用Comet技术达到向特定用户发送消息的功能。
